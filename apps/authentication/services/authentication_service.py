"""
Authentication Service - Business logic for enterprise user authentication.
"""

from django.contrib.auth import authenticate
from django.utils import timezone
from django.conf import settings
from rest_framework_simplejwt.tokens import RefreshToken
from apps.accounts.models import EnterpriseUser
from typing import Dict, Optional
import logging

logger = logging.getLogger('authentication')


class AuthenticationService:
    """
    Service class for handling enterprise authentication business logic.
    
    Implements:
    - User authentication validation
    - JWT token generation and management
    - Session management
    - 2FA code verification
    - Security checks and validation
    """
    
    def authenticate_enterprise_user(self, email: str, password: str, request=None) -> Dict:
        """
        Authenticate enterprise user with corporate credentials.
        
        Args:
            email: Corporate email address
            password: User password
            
        Returns:
            Dict containing authentication result and user data
            
        Raises:
            ValueError: If authentication fails
        """
        try:
            # Get user first to check account status
            try:
                user = EnterpriseUser.objects.get(corporate_email=email.lower())
            except EnterpriseUser.DoesNotExist:
                raise ValueError("Invalid credentials")
            
            # Check account status before authentication
            if not user.is_active:
                raise ValueError("Account is disabled")
            
            if user.is_account_locked():
                raise ValueError("Account is temporarily locked")
            
            if not user.email_verified:
                raise ValueError("Email address not verified")
            
            # Authenticate user with request parameter for django-axes
            authenticated_user = authenticate(request=request, username=email, password=password)
            if not authenticated_user:
                # Increment failed attempts
                user.increment_failed_attempts()
                raise ValueError("Invalid credentials")
            
            # Reset failed attempts on successful login
            user.reset_failed_attempts()
            
            return {
                'success': True,
                'user': authenticated_user,
                'requires_2fa': authenticated_user.is_2fa_enabled,
                'message': 'Authentication successful'
            }
            
        except ValueError:
            raise
        except Exception as e:
            logger.error(f"Authentication error for {email}: {str(e)}")
            raise ValueError("Authentication failed")
    
    def generate_2fa_code(self, user: EnterpriseUser) -> str:
        """
        Generate 2FA code for user (placeholder - TOTP is generated by authenticator app).
        
        Args:
            user: EnterpriseUser instance
            
        Returns:
            str: Status message (TOTP codes are generated by authenticator apps)
        """
        if not user.is_2fa_enabled:
            raise ValueError("2FA is not enabled for this user")
        
        return "2FA code should be generated by authenticator app"
    
    def verify_2fa_code(self, user: EnterpriseUser, code: str) -> bool:
        """
        Verify 2FA code against user's secret.
        
        Args:
            user: EnterpriseUser instance
            code: 6-digit TOTP code
            
        Returns:
            bool: True if code is valid, False otherwise
        """
        if not user.is_2fa_enabled:
            return False
        
        # Try TOTP verification first
        if user.verify_2fa_token(code):
            return True
        
        # Try backup code if TOTP fails
        return user.use_backup_code(code)
    
    def generate_jwt_tokens(self, user: EnterpriseUser) -> Dict[str, str]:
        """
        Generate JWT access and refresh tokens for authenticated user.
        
        Args:
            user: Authenticated EnterpriseUser instance
            
        Returns:
            Dict containing access_token, refresh_token, token_type, and expires_in
        """
        try:
            refresh = RefreshToken.for_user(user)
            
            # Add custom claims
            refresh['role'] = user.role
            refresh['department'] = user.department
            refresh['company_domain'] = user.company_domain
            refresh['is_2fa_enabled'] = user.is_2fa_enabled
            refresh['email_verified'] = user.email_verified
            refresh['full_name'] = user.full_name
            
            access_token = refresh.access_token
            
            return {
                'access_token': str(access_token),
                'refresh_token': str(refresh),
                'token_type': 'Bearer',
                'expires_in': access_token.payload['exp'] - int(access_token.current_time.timestamp()),
                'user_id': user.id,
                'corporate_email': user.corporate_email
            }
            
        except Exception as e:
            logger.error(f"Token generation error for user {user.id}: {str(e)}")
            raise ValueError("Failed to generate tokens")
    
    def invalidate_user_tokens(self, user: EnterpriseUser) -> bool:
        """
        Invalidate all tokens for a user (blacklist all refresh tokens).
        
        Args:
            user: EnterpriseUser instance
            
        Returns:
            bool: True if tokens were invalidated successfully
        """
        try:
            # This would require implementing a token blacklist
            # For now, we'll just update the user's last activity
            user.update_last_activity()
            return True
            
        except Exception as e:
            logger.error(f"Token invalidation error for user {user.id}: {str(e)}")
            return False
    
    def check_session_limits(self, user: EnterpriseUser) -> bool:
        """
        Check if user has exceeded concurrent session limits.
        
        Args:
            user: EnterpriseUser instance
            
        Returns:
            bool: True if within limits, False if exceeded
        """
        # This would require implementing session tracking
        # For now, always return True (no limits enforced)
        return True
    
    def validate_login_attempt(self, user: EnterpriseUser, ip_address: str) -> Dict:
        """
        Validate login attempt with security checks.
        
        Args:
            user: EnterpriseUser instance
            ip_address: Client IP address
            
        Returns:
            Dict containing validation result and any security alerts
        """
        alerts = []
        
        # Check for suspicious login patterns
        if user.last_login_ip and user.last_login_ip != ip_address:
            alerts.append({
                'type': 'location_change',
                'message': 'Login from different IP address detected',
                'previous_ip': user.last_login_ip,
                'current_ip': ip_address
            })
        
        # Check password expiry
        if user.is_password_expired():
            alerts.append({
                'type': 'password_expired',
                'message': 'Password has expired and must be changed',
                'expires_at': user.password_expires_at.isoformat() if user.password_expires_at else None
            })
        
        # Check failed attempts
        if user.failed_login_attempts > 0:
            alerts.append({
                'type': 'failed_attempts',
                'message': f'{user.failed_login_attempts} recent failed login attempts detected',
                'count': user.failed_login_attempts
            })
        
        return {
            'valid': True,
            'alerts': alerts,
            'requires_password_change': user.is_password_expired()
        }
    
    def update_login_metrics(self, user: EnterpriseUser, ip_address: str, user_agent: str) -> None:
        """
        Update user login metrics and tracking information.
        
        Args:
            user: EnterpriseUser instance
            ip_address: Client IP address
            user_agent: Client user agent string
        """
        try:
            user.update_login_info(ip_address, user_agent)
            user.update_last_activity()
            
        except Exception as e:
            logger.error(f"Login metrics update error for user {user.id}: {str(e)}")
    
    def check_security_requirements(self, user: EnterpriseUser) -> Dict:
        """
        Check if user meets current security requirements.
        
        Args:
            user: EnterpriseUser instance
            
        Returns:
            Dict containing security compliance status
        """
        requirements = {
            'email_verified': user.email_verified,
            '2fa_enabled': user.is_2fa_enabled,
            'password_current': not user.is_password_expired(),
            'account_active': user.is_active,
            'account_unlocked': not user.is_account_locked()
        }
        
        # Check enterprise-wide 2FA enforcement
        enforce_2fa = getattr(settings, 'ENABLE_2FA_ENFORCEMENT', False)
        if enforce_2fa and not user.is_2fa_enabled:
            requirements['2fa_required'] = True
        
        all_met = all(requirements.values())
        
        return {
            'compliant': all_met,
            'requirements': requirements,
            'missing_requirements': [
                key for key, value in requirements.items() 
                if not value
            ]
        }
    
    def get_user_authentication_history(self, user: EnterpriseUser, limit: int = 10) -> Dict:
        """
        Get user's recent authentication history.
        
        Args:
            user: EnterpriseUser instance
            limit: Number of recent entries to return
            
        Returns:
            Dict containing authentication history
        """
        try:
            # This would query audit logs for authentication events
            # For now, return basic user info
            return {
                'user_id': user.id,
                'last_login': user.last_login.isoformat() if user.last_login else None,
                'last_login_ip': user.last_login_ip,
                'failed_attempts': user.failed_login_attempts,
                'account_created': user.created_at.isoformat(),
                'is_2fa_enabled': user.is_2fa_enabled,
                'password_changed_at': user.password_changed_at.isoformat() if user.password_changed_at else None
            }
            
        except Exception as e:
            logger.error(f"Authentication history error for user {user.id}: {str(e)}")
            return {}
    
    def force_password_reset(self, user: EnterpriseUser) -> bool:
        """
        Force password reset for a user (mark password as expired).
        
        Args:
            user: EnterpriseUser instance
            
        Returns:
            bool: True if reset was initiated successfully
        """
        try:
            user.password_expires_at = timezone.now()
            user.save(update_fields=['password_expires_at'])
            return True
            
        except Exception as e:
            logger.error(f"Force password reset error for user {user.id}: {str(e)}")
            return False
    
    def lock_user_account(self, user: EnterpriseUser, duration_minutes: int = 15, reason: str = '') -> bool:
        """
        Lock user account for security reasons.
        
        Args:
            user: EnterpriseUser instance
            duration_minutes: Lock duration in minutes
            reason: Reason for locking
            
        Returns:
            bool: True if account was locked successfully
        """
        try:
            user.lock_account(duration_minutes)
            
            # Log the lock reason if provided
            if reason:
                logger.warning(f"Account locked for user {user.corporate_email}: {reason}")
            
            return True
            
        except Exception as e:
            logger.error(f"Account lock error for user {user.id}: {str(e)}")
            return False
